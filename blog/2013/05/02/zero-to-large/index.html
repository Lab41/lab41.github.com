
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Zero to Large - { blog }</title>
  <meta name="author" content="Lab41">

  
  <meta name="description" content="This first post is intended to introduce the type of work we’ve started at Lab41, which is a unique partnership In-Q-Tel has started with Academia, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://va-vsrv-github.a.internal/blog/2013/05/02/zero-to-large/">
  <link href="/pages/lab41/blog-preview/favicon.png" rel="icon">
  <link href="/pages/lab41/blog-preview/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/pages/lab41/blog-preview/javascripts/ender.js"></script>
  <script src="/pages/lab41/blog-preview/javascripts/modernizr-2.0.js"></script>
  <script src="/pages/lab41/blog-preview/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="{ blog }" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="/pages/lab41/blog-preview/stylesheets/custom/bootstrap.min.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/pages/lab41/blog-preview/stylesheets/custom/jquery.fancybox.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/pages/lab41/blog-preview/stylesheets/custom/jquery.fancybox-extra.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/pages/lab41/blog-preview/stylesheets/custom/jquery.fancybox-buttons.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/pages/lab41/blog-preview/stylesheets/custom/jquery.fancybox-thumbs.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/pages/lab41/blog-preview/stylesheets/tables.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/pages/lab41/blog-preview/stylesheets/custom/kronecker.css" media="screen, projection" rel="stylesheet" type="text/css">

<script src="/pages/lab41/blog-preview/javascripts/jquery-1.9.0.min.js" type="text/javascript"></script>

<script src="/pages/lab41/blog-preview/javascripts/fancybox/jquery.fancybox.js" type="text/javascript"></script>
<script src="/pages/lab41/blog-preview/javascripts/fancybox/jquery.fancybox-activate.js" type="text/javascript"></script>
<script src="/pages/lab41/blog-preview/javascripts/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>
<script src="/pages/lab41/blog-preview/javascripts/fancybox/jquery.fancybox-buttons.js" type="text/javascript"></script>
<script src="/pages/lab41/blog-preview/javascripts/fancybox/jquery.fancybox-media.js" type="text/javascript"></script>
<script src="/pages/lab41/blog-preview/javascripts/fancybox/jquery.fancybox-thumbs.js" type="text/javascript"></script>
<script src="/pages/lab41/blog-preview/javascripts/jquery.mousewheel-3.0.6.pack.js" type="text/javascript"></script>
<script src="/pages/lab41/blog-preview/javascripts/r_syntax.js" type="text/javascript"></script>
<script src="/pages/lab41/blog-preview/javascripts/google_analytics.js" type="text/javascript"></script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/2.10.0/d3.v2.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script> 

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script>
<script src="/pages/lab41/blog-preview/javascripts/mathjax.js" type="text/x-mathjax-config"></script>
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript" src="/pages/lab41/blog-preview/javascripts/kroneckerapp.js"></script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-40906884-1, UA-40464073-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/pages/lab41/blog-preview/"><img src="/pages/lab41/blog-preview/images/lab41/logo.png" width="212" height="50" alt='Logo' %}> { blog }</a></h1>
  
    <h2>innovation through collaboration</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:va-vsrv-github.a.internal" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/pages/lab41/blog-preview/">Blog</a></li>
  <li><a href="/pages/lab41/blog-preview/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Zero to Large</h1>
    
    <h4 class="subtitle">Generating Billion-node Graphs for Distributed Graph Databases</h4>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-02T15:22:00-07:00" pubdate data-updated="true">May 2<span>nd</span>, 2013</time>
        
  

<span class="byline author vcard"> - <span class="fn">Charlie Lewis</span></span>

        
        
      </p>
    
  </header>


<div class="entry-content"><blockquote>
<p>This first post is intended to introduce the type of work we’ve started at Lab41, which is a unique partnership In-Q-Tel has started with Academia, Industry, and the U.S. Intelligence Community. We’re excited about this venture and look forward to sharing our progress towards collaboratively addressing big data challenges with new technologies.</p>
</blockquote>
<p>Designing scalable systems for the real world requires careful consideration of data – namely, Big Data’s volume, variety, and velocity – to ensure the right pieces are engineered and valuable resources don’t miss the gotchas or edge cases that lead to insight. Basically, when tinkering with different architectures in the Big Data arena, having good data to test against is paramount. One of our projects involves assessing various architectures for working with large-scale graphs, including how to incorporate data that tests the limits of storage, computation, and analytic workflows.</p>
<p>As you might expect, we wanted to use real world data when designing our real-world system. However, getting real data that mimics production data is difficult and time consuming. Oftentimes data only tells a story for that specific dataset, leading a developer to miss the more comprehensive view of the system’s strengths and weaknesses. For those reasons, we developed a method that generates large graphs with the “right” qualities of a system that can scale to one billion nodes.</p>
<h3 id="initial-requirements">Initial Requirements</h3>
<p>Before comparing the leading projects for scaling graphs, we needed a good baseline for assessing the data requirements of the overall system. It quickly became apparent that current offerings such as <a href="http://gephi.org/">Gephi</a>, <a href="http://nwb.cns.iu.edu/">Network WorkBench</a>, <a href="http://networkx.github.com/">NetworkX</a>, and <a href="https://github.com/tinkerpop/furnace">Furnace</a>, all do a good job of following particular distributions and structural constraints. However, most of them are unable to generate graphs at large scale <strong>and</strong> produce the correct format <strong>and</strong> build to completion <strong>and</strong> finish in a reasonable amount of time.</p>
<p>The evaluation and assessment of graph data generators led us down the path of writing a fairly-straightforward script. The <a href="http://lab41.github.io/graph-generators/">code</a> is very young in its development – and has room for a lot of improvement – but it has proven simple to use, moderately good at generating graphs large enough to test claims, and flexible enough to vary characteristics such as directed-ness, out-degrees, and of course numbers of edges, nodes, and attributes. We made sure to add a twist of randomness to avoid creating identical graphs.</p>
<p>The script takes command-line switches to configure the following graph characteristics:</p>
<ul>
<li>Number of nodes</li>
<li>Degree of nodes</li>
<li>In-degree of nodes</li>
<li>Out-degree of nodes</li>
<li>Number of node attributes</li>
<li>Number of edge attributes</li>
<li>Directed-ness</li>
<li>Output type (GraphML and GraphSON so far)</li>
</ul>
<h4 id="practical-considerations">Practical Considerations</h4>
<p>With our script in hand, we moved on to begin the requisite performance testing, but we first discovered an important consideration for anyone wishing to release our script into the wild.</p>
<p><strong>The most important “practical” consideration proved to be enforcement (or not) of strict parameters, which forces the script to scan and verify characteristics of all nodes.</strong> By enforcing strict parameters, we mean that:</p>
<ul>
<li>each node must guarantee
<ul>
<li>that it has no more and no less edges attached to it
<ul>
<li>from both an in and out degree context.</li>
</ul></li>
</ul></li>
</ul>
<p>In order to guarantee this 100% of the time, each time an edge is added, all preexisting edges must be checked to make sure that the chosen random vertices chosen do not go outside the imposed limits. To put it in perspective, the script initially enforces strict parameters, which – as you can probably guess by now – simply become untenable for quickly producing large graph data sets. As the below chart shows, we are able to generate a graph of 100 Million nodes in roughly the same amount of time it took to generate a graph of only 100,000 nodes using strict parameter enforcement:</p>
<p>Click to enlarge: <a class="fancybox-effects-a"  href=/images/post_1/image_1.png><img src="/pages/lab41/blog-preview/images/post_1/image_1.png" title="Comparing Graph Generation Time With and Without Strict Parameters" ></a></p>
<p>Since disabling strict enforcement led to a graph three orders of magnitude larger in the same amount of time, you might be asking how the absence of that check – the degree of edges/node – affected the number of edges. Below we show that the difference of edges between checking and not checking is negligible:</p>
<p><a class="fancybox-effects-a"  href=/images/post_1/image_2.png><img src="/pages/lab41/blog-preview/images/post_1/image_2.png" title="Difference of \# of Edges Created" ></a></p>
<p>Since we are generating these graphs, it seems reasonable to bend the requirements slightly to treat the minima and maxima simply as guidelines that some nodes may not conform to. While there is still room for improvement, such as leveraging more than a single CPU core, the results are reasonable enough to use.</p>
<h3 id="generating-the-baseline">Generating the Baseline</h3>
<p><strong>The most important point is that seemingly “simple” parameter changes – which represent actual differences in real-world networks – make huge differences to the resulting network and therefore our system design.</strong> We generated three different classes of graphs from a baseline of graph data sets to determine how varying parameters influences such important characteristics as: time to generate, number of edges created, storage footprint, number of node and edge attributes, and average degree of nodes.</p>
<p>Each graph was generated with an increasing value of nodes, while all other settings were static between generations, per graph type. Graph types A, B, and C – described below – will be used in the next couple of charts:</p>
<pre><code>Graph Type: A B C
Magnitude: 1K - 1B 1K - 100M 1K - 100K
Format: graphml* graphml* graphml*
Directed: No No No
Minimum Degree: 1 1 1
Maximum Degree: 10 10 Same number as nodes
Minimum Node Attributes: 2 50 2
Maximum Node Attributes: 2 100 2
Minimum Edge Attributes: 0 5 0
Maximum Edge Attributes: 0 25 0</code></pre>
<blockquote>
<p>GraphML (<a href="http://graphml.graphdrawing.org/">http://graphml.graphdrawing.org/</a>) is a convenient XML format that describes nodes in terms of names and types with labeled edges between nodes.</p>
</blockquote>
<h4 id="number-of-nodes">Number of Nodes</h4>
<p>The first chart illustrates how the number of nodes greatly influences all other characteristics. While Type A generated one billion nodes in approximately 24 hours, the same timeframe yielded graphs of Type B with only 10 Million nodes and Type C with a scant one million nodes:</p>
<p><a class="fancybox-effects-a"  href=/images/post_1/image_3.png><img src="/pages/lab41/blog-preview/images/post_1/image_3.png" title="Time to generate graphs with different characteristics" ></a></p>
<h4 id="edges">Edges</h4>
<p>As this is just a first cut, restricting the number of nodes on the graph types seems acceptable for now. The following illustrates that limiting Type C to only 100,000 nodes still produces almost the same number of edges as a one billion node version of graph A:</p>
<p><a class="fancybox-effects-a"  href=/images/post_1/image_4.png><img src="/pages/lab41/blog-preview/images/post_1/image_4.png" title="Edges created generating graphs with different characteristics" ></a></p>
<h4 id="storage-footprint">Storage Footprint</h4>
<p>The following chart shows that a one billion node graph of Type B would require approximately 10TB of storage space, while Type C would require 300 Petabytes (!) to reach one billion nodes:</p>
<p><a class="fancybox-effects-a"  href=/images/post_1/image_5.png><img src="/pages/lab41/blog-preview/images/post_1/image_5.png" title="Storage footprint of generating graphs with different characteristics" ></a></p>
<p>Sadly, I couldn’t justify buying 300 <a href="http://www.aberdeeninc.com/abcatg/petarack.htm">Petaracks</a> just to generate the world’s most unrealistic graph. Not to mention it would have taken approximately 20,000 <strong>years</strong> to generate, but that’s beside the point.</p>
<h4 id="attributes">Attributes</h4>
<p>When looking at attribute differences, Type B creates about 30-40 times more attributes than the fairly-similar Types A and C:</p>
<p><a class="fancybox-effects-a"  href=/images/post_1/image_6.png><img src="/pages/lab41/blog-preview/images/post_1/image_6.png" title="Node attributes created generating graphs with different characteristics" ></a></p>
<h4 id="node-degree">Node Degree</h4>
<p>Finally, this last chart shows how the degree of each node for Type C grows exponentially with the number of nodes, whereas the average degree for the other two graph types remain static:</p>
<p><a class="fancybox-effects-a"  href=/images/post_1/image_7.png><img src="/pages/lab41/blog-preview/images/post_1/image_7.png" title="Average degree of nodes generating graphs with different characteristics" ></a></p>
<h3 id="loading-the-data">Loading the Data</h3>
<p>Now that we generated our various graph datasets, we need to load them into a distributed graph data store. For a variety of reasons, we decided to use <a href="http://thinkaurelius.github.com/titan/">Titan</a> with an <a href="http://hbase.apache.org/">HBase</a> backend.</p>
<p>One of the nice things about Titan is that its <a href="https://github.com/tinkerpop/gremlin/wiki">Gremlin console shell</a> enables graph interaction, traversals, and calculations. It also has functions for loading a graph file into the graph data store, which in this case is HBase on top of HDFS. Unfortunately, Gremlin through Titan does not leverage the <a href="http://www.kchodorow.com/blog/2010/03/15/mapreduce-the-fanfiction/">awesomeness of MapReduce</a> that generally goes hand-in-hand with HBase and its Hadoop counterparts. So running the import in parallel is currently impossible. In terms of data formats, Gremlin on Titan can load GraphML; however, the current ID scheme prevents federation of GraphML across multiple machines (or even multiple cores). So as you can see from the chart below, the load times are un-spectacular:</p>
<p><a class="fancybox-effects-a"  href=/images/post_1/image_8.png><img src="/pages/lab41/blog-preview/images/post_1/image_8.png" title="Load time of graph types using Gremlin with Titan" ></a></p>
<blockquote>
<p>*Note: ‘Minimal Degree and Attributes’ corresponds to ‘Graph A’ from above, similarly ‘Heavy Attributes’ and ‘Heavy Degree’ correspond to ‘Graph B’ and ‘Graph C’, respectively.</p>
</blockquote>
<p>Fret not! <a href="http://thinkaurelius.github.com/faunus/">Faunus</a> to the rescue! Faunus uses a Gremlin shell, which is similar to Titan’s and one we can use for importing a slightly different data format to gain benefits via MapReduce. The next chart shows the benefits of moving from GraphML to loading the GraphSON* format using a MapReduce job:</p>
<p><a class="fancybox-effects-a"  href=/images/post_1/image_9.png><img src="/pages/lab41/blog-preview/images/post_1/image_9.png" title="Load time comparison using Gremlin with Titan versus Gremlin with Faunus" ></a></p>
<blockquote>
<p>*Note: <a href="https://github.com/thinkaurelius/faunus/wiki/GraphSON-Format">GraphSON</a>, which is slightly modified from <a href="https://github.com/tinkerpop/blueprints/wiki/GraphSON-Reader-and-Writer-Library">traditional GraphSON</a>, is a one-record-per-line JSON-style format that describes nodes in terms of names, types, and labeled edges.</p>
</blockquote>
<h3 id="conclusion">Conclusion</h3>
<p><strong>Our <a href="https://github.com/Lab41/graph-generators">Graph-generation Code</a> allows us to generate one-billion node graphs with varying characteristics such as directed-ness, number of edges and nodes, and node degrees. Just as important, we determined how the different characteristics affect real-world considerations such as loading time and storage footprint, also finding an early optimization through MapReduce parallel processing.</strong> As we move to the next phase of designing around the data, we anticipate shortly being able to improve at least a couple orders of magnitude through fairly straightforward tweaks such as parallelizing load computations across a cluster. Of course this is only the first step, and there is a long exciting road ahead of us.</p>
<h4 id="standard-disclaimer">Standard Disclaimer</h4>
<p>As is usually the case, it should be noted that this is not necessarily representative of the technology’s overall performance characteristics, but rather our experience within a specific environment. We used the following environment for our tests:</p>
<p><strong>Environment:</strong></p>
<pre><code>GRAPH GENERATION:

    Run on a MacBook Air 2GHz Intel Core i7, 8GB 1600 MHz DDR3

    Python 2.7.2 (default, Jun 20 2012, 16:23:33)
    [GCC 4.2.1 Compatible Apple Clang 4.0 (tags/Apple/clang-418.0.60)] on darwin

LOADING GRAPHS:

    Gremlin with Titan:
        Virtual Machine, Ubuntu 12.04 LTS, 4 core processor, 8GB RAM
        Started with the default Java options for Gremlin of:
            JAVA_OPTIONS=&quot;-Xms32m -Xmx512m
        Then bumped that up as the graph file got larger to:
            JAVA_OPTIONS=&quot;-Xms256m -Xmx4096m

    Gremlin with Faunus:
        Virtual Machine, Ubuntu 12.04 LTS, 2 core processor, 4GB RAM

    Hadoop/HBase Cluster:
        12 node cluster - 8 core processors, 64GB RAM, CDH4.2, heap set to 4GB, HBase 0.94.2</code></pre></div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Charlie Lewis</span></span>

      








  


<time datetime="2013-05-02T15:22:00-07:00" pubdate data-updated="true">May 2<span>nd</span>, 2013</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="https://va-vsrv-github.a.internal/blog/2013/05/02/zero-to-large/" data-via="" data-counturl="https://va-vsrv-github.a.internal/blog/2013/05/02/zero-to-large/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
      
        <a class="basic-alignment right" href="/pages/lab41/blog-preview/blog/2013/06/12/i-see-graphs/" title="Next Post: I See Graphs">I See Graphs &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  This project is maintained by the <a href="https://github.com/LAB41">Lab41</a> Team to serve as a platform of discussion on technology topics relevant to Lab41 Challenges. More information about Lab41 can be found at <a href="www.lab41.org">www.lab41.org</a>.
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/pages/lab41/blog-preview/blog/2013/08/27/stochastic-kronecker-natural-graphs/">Stochastic Kronecker natural graphs</a>
      </li>
    
      <li class="post">
        <a href="/pages/lab41/blog-preview/blog/2013/06/12/i-see-graphs/">I See Graphs</a>
      </li>
    
      <li class="post">
        <a href="/pages/lab41/blog-preview/blog/2013/05/02/zero-to-large/">Zero to Large</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/lab41">@lab41</a> on GitHub
  
  <script type="text/javascript">
   (function($) {
    $(document).on('ready', function() {
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'lab41',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
   })(jQuery);
  </script>
  <script src="/pages/lab41/blog-preview/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
  <h1>Blog Authors</h1>
  <ul id="blog_authors">
    
      
    
      
    
      
    
    <li><a href="https://github.com/karkumar">Karthik Ramachandran</a></li>
    <li><a href="https://github.com/cglewis">Charlie Lewis</a></li>
    <li><a href="https://github.com/nadesai">Nikhil Desai</a></li>
    <li></li>
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Lab41 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a>. Design by <a href="http://octopressthemes.com">Octopress Themes</a>.</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'https://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
